---
title: 'Mocking Fundamentals'
part: 3
date: '2020-04-28'
categories: [tools]
tags: [js, testing]
source: [egghead]
---

# Mocking Fundamentals

This section implements mocking in vanilla JS without help from testing frameworks and helper functions like Jest. The goal is to better understand how mocking works behind the scenes.

## What is Mocking?

The idea behind mocking comes when you have some module that is too expensive to use directly. For example, there could be asynchronous functions involved, or it could be processing a credit card payment, which is too expensive to actually test.

So, you create a **fake** or **mock** version of the module, so you can test the module without incurring the costs.

## Monkey-patching: Overriding Object Properties

The process of **monkey-patching** is to

1. **Override** the object method with your own mock method.
2. **Cleanup** that mock method by reassigning the key to the original method _after_ you're done your test. (This is so other tests aren't affected by what happens in the target test.)

In the example below, we have a `utils` object with helper functions that we need to monkey-patch:

```js
const assert = require('assert');
const thumbWar = require('../thumb-war');
const utils = require('../utils');

// Override/monkey patch
const originalGetWinner = utils.getWinner; // store original
utils.getWinner = (p1, p2) => p1; // this method is now deterministic for easier testing

const winner = thumbWar('Kent C. Dodds', 'Ken Wheeler');
assert.strictEqual(winner, 'Kent C. Dodds');

// Cleanup
utils.getWinner = originalGetWinner;
```

## Testing Function Calls with Mocks

### Jest version

A **mock function** is a special function that stores properties as it's called, making the function easier to test. We will be recreating some of the functionality of `jest.fn`.

In Jest, here's some cool things you can do:

```js
utils.getWinner = jest.fn((p1, p2) => p1); // custom implementation

const winner = thumbWar('Kent C. Dodds', 'Ken Wheeler');

// You can test number of times called
expect(utils.getWinner).toHaveBeenCalledTimes(2);
// You can test arguments passed in calls
expect(utils.getWinner.mock.calls).toEqual([
  ['Dan', 'John'],
  ['Dan', 'John'],
]);
```

### Our version

Here's a bare-bones **mock factory function**. It creates a mock function that utilizes a user-provided **implementation** of that function. That implementation replaces the original implementation:

```js
const fn = implementation => {
  const mockFn = (...args) => {
    return implementation(...args);
  };
  return mockFn;
};
```

We want to add the following features to our mock function:

- Stores number of times it's been called.
- Stores the arguments passed into each call.

```js
const fn = implementation => {
  const mockFn = (...args) => {
    mockFn.numCalls++;
    mockFn.mockFn.mock.calls.push(args);
    return implementation(...args);
  };

  // Initialize starting values
  mockFn.numCalls = 0;
  mockFn.mock = { calls: [] };

  return mockFn;
};
```

Now we can perform tests to make sure our mock function ran as many times as we expected _and_ with the arguments we expected.

```js
const originalWinner = utils.getWinner;
utils.getWinner = fn((p1, p2) => p1); // deterministic

utils.getWinner('Dan', 'John');
utils.getWinner('Dan', 'John');

expect(utils.getWinner.numCalls).toBe(2);
expect(utils.getWinner.mocks.calls).toEqual([
  ['Dan', 'John'],
  ['Dan', 'John'],
]);

// Cleanup
utils.getWinner = originalWinner;
```

## Restoring Original Implementation

We don't want to have to monkey-patch as our way to mock our function and then restore it. We can instead use `spyOn` and `mockRestore` to do that for us.

### Jest version

In Jest, here's the code:

```js
// Overrides original function with mock function at 'getWinner' key
jest.spyOn(utils, 'getWinner');
// Adds custom implementation to pre-existing mock function (instead of during initialization)
utils.getWinner.mockImplementation((p1, p2) => p1);

// Run tests...

// Cleanup
utils.getWinner.mockRestore();
```

### Our version

To recreate the above functionality, here are the requirements:

1. `spyOn` needs to override the original function with a mock function generated by `fn`.
   - **Note**: `fn` needs to accept zero arguments here because the implementation comes _after_.
2. We need a `mockRestore` method that resets the function back to its original state.
3. We need a `mockImplementation` method that updates the implementation.

**Note**: Our solution below uses **closures** to solve 2 and 3.

```js
// Default empty function solves 1
function fn(impl = () => {}) {
  const mockFn = (...args) => {
    mockFn.mock.calls.push(args);
    return impl(...args);
  };
  mockFn.mock = { calls: [] };
  // Using closure, we can update our implementation to solve 3
  mockFn.mockImplementation = newImpl => (impl = newImpl);
  return mockFn;
}

function spyOn(object, property) {
  // By storing original implementation, we can override with a mock function
  // Then using closure, we can restore to the original implementation to solve 2
  const originalImpl = object[property];
  object[property] = fn();
  object[property].mockRestore = () => {
    object[property] = originalImpl;
  };
}
```
